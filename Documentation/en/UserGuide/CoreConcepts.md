# Core Concepts Guide

## Overview

This guide explains the core concepts of ByenatOS in detail, helping you understand how the AI operating system works.

## Core Concepts

### 1. AI Operating System Architecture

ByenatOS adopts an **AI Operating System** architecture, treating each app with AI capabilities as a complete computer in the AI era:

- **APP = A complete computer in the AI era**: Responsible for user interaction, interface display, and business logic
- **byenatOS = AI Operating System**: Manages interactions between applications and local large models
- **Local Large Model = CPU**: Specialized in processing personalized intelligent computing

### 2. HiNATA Data Format

HiNATA is a unified large model-friendly data format, stored in JSON Lines (JSONL) format:

```json
{
  "id": "hinata_20241201_001",
  "timestamp": "2024-12-01T10:30:00Z",
  "source": "app_name",
  "highlight": "Content that users focus on or mark",
  "note": "Notes and annotation information added by users",
  "address": "Address or location information of data source",
  "tag": ["category", "retrieval_tag"],
  "access": "public|private|restricted",
  "embedding_vector": [0.1, 0.2, ...],
  "metadata": {
    "confidence": 0.95,
    "processing_time": "0.1s",
    "version": "1.0"
  }
}
```

#### Definition of Highlight and Note

- **Highlight**: Content fragments that users actively mark, select, or focus on, usually the "title" or "keywords" of information
- **Note**: Detailed content, comments, explanations, or complete information added by users

#### Typical Application Scenarios

1. **Article Reading**: Highlighted text fragments = highlight, user comments = note
2. **Article Collection**: Article title = highlight, full article = note
3. **Photo Recording**: Photo title = highlight, photo content = note
4. **Nested Comments**: Original note = highlight, new comment = note

### 3. Personal System Prompt (PSP)

PSP is the core output management mechanism of the operating system, generated by processing HiNATA data through local large models, controlling personalized experiences for all user interactions.

#### PSP Classification Output Architecture

**Core Memory Layer**:
- **PersonalRules** - System-level rules and behavioral patterns based on deep personal understanding
- **CognitivePatterns** - User thinking habits, decision patterns, problem-solving preferences
- **ValueSystem** - Personal values, principles, moral boundaries
- **PreferenceProfile** - Long-term stable preference settings (interaction methods, content types, response styles)

**Working Memory Layer**:
- **PriorityRules** - Priority rules and temporary adjustments based on recent focus
- **ActiveContext** - Current work focus, recent projects and task status
- **RecentPatterns** - Short-term behavioral changes and emerging interests
- **SessionGoals** - Specific goals for current session or time period

**Learning Memory Layer**:
- **SuccessPatterns** - Records of effective interaction patterns and successful experiences
- **ErrorCorrections** - Adjustments and improvements learned from errors
- **AdaptationLog** - Evolution trajectory of personal preferences and adaptive changes
- **FeedbackIntegration** - Continuous optimization driven by user feedback

**Context Memory Layer**:
- **DomainKnowledge** - Knowledge graph and expertise mapping in user's professional field
- **RelationshipMap** - Social relationships, collaboration patterns, communication preferences
- **EnvironmentProfile** - Environmental characteristics of devices, applications, and usage scenarios
- **TimingPatterns** - Time-sensitive behavioral patterns and periodic needs

### 4. HiNATA vs PSP: Virtual Hard Drive vs Virtual Memory

**Key Design Principles**:
- **HiNATA ≈ Virtual Hard Drive** - Unlimited capacity storage, preserving all historical personal data
- **PSP ≈ Virtual Memory** - Strict capacity limits (prompt length), high-quality curated content

**Why This Analogy is Critical**:
Due to online AI model context window limitations, PSP must maximize personalized effects within limited space. This requires byenatOS to design a "memory manager" similar to an operating system, intelligently filtering the most relevant and important information from massive HiNATA data to generate PSP.

### 5. PSP Strategy Management Mechanism

#### Dual-Layer Strategy Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                PSP Strategy Management System               │
├─────────────────────────────────────────────────────────────┤
│ PSP Production Strategy (Low Frequency) │ Generate strategy candidates from HiNATA deep analysis │
│ • Daily/Weekly execution                │ • User behavior pattern mining                        │
│ • Strategy Library Construction         │ • Multiple memory strategy generation                  │
├─────────────────────────────────────────────────────────────┤  
│ PSP Call Strategy (High Frequency)   │ Smartly select and combine the optimal PSP                   │
│ • Each query execution       │ • Contextual relevance matching                    │
│ • Dynamic strategy combination       │ • Maximize effect within Token limit               │
├─────────────────────────────────────────────────────────────┤
│ User Feedback Loop         │ Based on satisfaction to drive strategy iteration                │
│ • Satisfaction Score         │ • Strategy weight dynamic adjustment                    │
│ • Strategy Effect Tracking       │ • Continuous optimization and improvement                        │
└─────────────────────────────────────────────────────────────┘
```

#### User Feedback Driven Iteration

1. **Satisfied Feedback** → Strengthen relevant strategy weights, increase call probability
2. **Dissatisfied Feedback** → Reduce strategy weights, trigger new strategy generation
3. **Strategy Attribution** → Accurately pinpoint which strategy led to good/bad results
4. **Effect Evaluation** → Long-term tracking of strategy performance, eliminate low-efficiency strategies
5. **Continuous Learning** → Based on feedback, continuously optimize strategy selection and combination

#### Intelligent Strategy Selection Algorithm

- **Context Matching** - Select relevant strategies based on query type
- **Historical Effect** - Prioritize strategies that have performed well in the past
- **Strategy Combination** - Multiple intelligent strategy combinations, avoiding conflicts
- **Token Optimization** - Maximize personalized value within length limits

## Data Flow Processing

### HiNATA Data Flow Processing

1. **Real-time Reception** - Operating system continuously receives HiNATA files from applications
2. **Format Validation** - Validate JSONL format and completeness of necessary fields
3. **Embedding Generation** - Use local large models to generate vector representations
4. **Vector Storage** - Store embeddings in vector databases
5. **Similarity Matching** - Calculate vector similarity with existing PSPs

### PSP Iterative Update Process

1. **Pattern Recognition** - Analyze user behavior patterns in HiNATA data stream
2. **Intent Extraction** - Extract real intent from user focus points
3. **PSP Matching** - Match new intent with existing PSPs and fuse
4. **Incremental Update** - Incrementally update PSP based on matching results
5. **Validation Feedback** - Verify the accuracy of PSP updates through user interaction

### Automatic Trigger Updates

- **Real-time Learning** - Incremental updates based on HiNATA data stream
- **Pattern Recognition** - Adaptive adjustment when new behavior patterns are detected
- **Anomaly Detection** - Re-evaluation when conflicts with existing patterns are found

### Manual Marked Updates

- **Importance Marking** - User-initiated key information and preferences marked
- **Error Correction** - Direct correction of system misunderstandings
- **Target Adjustment** - Explicit indication of priority and target changes

## Application Collaboration Mechanism

### Log App Example

1. **Data Generation Phase** - Users record work content, ideas, and plans in the Log App
2. **HiNATA Conversion** - App converts content to standardized HiNATA format
3. **System Processing** - byenatOS analyzes user work patterns, focus areas, and thinking habits
4. **PSP Update** - Form memory rules: "User focuses on technical issues, prefers concise answers"
5. **AI Enhancement** - When users use the AI function of the Log App, they obtain personalized suggestions based on their personal memory

### ReadItLater App Example

1. **Reading Behavior** - Users collect articles, add annotations, and record ideas
2. **Memory Extraction** - System identifies user's reading memory, knowledge domain, and focus direction
3. **Smart Recommendation** - App's AI function provides personalized content recommendations based on user PSP
4. **Continuous Optimization** - Through reading feedback, continuously optimize recommendation algorithms and content screening

## System Output Management

### PersonalizationEngine Layer Core Responsibilities

**Data Processing Module**:
1. **HiNATA Data Collector** - Unifies HiNATA format data received from various applications
2. **Format Validation and Standardization** - Ensures data quality and consistency
3. **Cross-application Data Fusion** - Integrates multi-source data from Log App, ReadItLater App, etc.

**Smart Analysis Module**:
4. **Behavior Pattern Recognition** - Analyzes user behavior characteristics across different applications
5. **Memory Mining Engine** - Extracts deep memory and interests from user operations
6. **Contextual Association Analysis** - Establishes cross-application user behavior correlation graph

**PSP Management Module**:
7. **Memory Rule Generation** - Generates PSP components based on analysis results
8. **Hierarchical Memory Management** - Maintains core memory, working memory, and multiple layers
9. **Dynamic Update Mechanism** - Real-time adjustment and optimization of PSP content

**Service Output Module**:
10. **PSP API Service** - Provides standardized memory interfaces for applications
11. **Experience Coordination Center** - Ensures consistency of memory experiences across applications
12. **Privacy Boundary Control** - Manages access permissions and privacy protection for memory data

### System-level Output Management Strategy

1. **Unified Output Control** - PSP as the system-level output management mechanism, ensuring consistency of all interactions
2. **Hierarchical Output Management** - Different PSP controls memory experiences at different granularity levels
3. **Real-time Output Adjustment** - Adjust output strategies based on user behavior and context in real-time
4. **Privacy-protected Output** - Ensure output content complies with user privacy preferences and security requirements

### Hierarchical Memory Management Principles

1. **Stability Layer** - Core memory changes slowly, working memory adapts quickly
2. **Priority Management** - Important memory receives more weight and protection
3. **Timeliness Balance** - Smart fusion of new information with historical patterns
4. **Privacy Boundary** - Different memory levels have different access controls

## Storage Architecture Design

### Main File Format
- **JSON Lines (.jsonl)** - Supports streaming read/write, convenient for large model processing

### Index File
- **SQLite Database** - Fast retrieval and querying

### Vector Storage
- **FAISS or Chroma** - Efficient embedding matching

### Compression Strategy
- **LZ4 Compression** - Reduces storage space while maintaining read speed

## Comparison with Traditional Architecture

### Traditional Mode Problems
- Each APP needs to build its own memory system separately
- User memory learning results cannot be shared across APPs
- High development costs, inconsistent personalized effects

### ByenatOS Advantages
- Unified AI operating system (manages all AI interactions)
- Cross-APP memory sharing and accumulation
- APP developers only need to focus on business logic, AI capabilities are plug-and-play

## Technical Features

### Specialized Intelligent Processing
- Focuses on memory data analysis and PSP generation
- Like an operating system calling CPU to process instructions

### Complete Localization
- Personal data processing completed locally on the device
- Runs as an AI operating system

### Lightweight and Efficient
- Optimized operating system architecture
- Fast response (<500ms), low resource usage

### Deep Memory
- Specialized analysis of cross-application user behavior patterns
- Generates precise memory rules

### Intelligent Collaboration
- Perfect bridge between APP and local large models
- Operating system + CPU collaboration

### Continuous Optimization
- Continuously improves memory effects through multi-application data

## Security and Privacy

### Operating System Security Protection
- Establishes a secure isolation layer between APP and local large models
- Protects user data from direct exposure to online services

### Privacy Boundary Control
- As an operating system, manages access permissions for personalized data
- Ensures different memory levels have different access controls

## Deployment Architecture

### Cross-platform Support
- Supports deployment on Windows, macOS, Linux, and other platforms
- Runs as a background service without affecting existing application ecosystem

### Lightweight Deployment
- Optimized virtual architecture
- Fast response, low resource usage

### Optional Cloud Collaboration
- Supports cross-device PSP synchronization (encrypted transmission)
- Maintains local processing while supporting multi-device synchronization 